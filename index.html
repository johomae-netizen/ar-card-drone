<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>AR Drone - Single Instance</title>

  <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
  <script src="https://cdn.rawgit.com/jeromeetienne/AR.js/1.7.7/aframe/build/aframe-ar.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>

  <style>
    body {
      margin: 0; overflow: hidden; background: #000;
      touch-action: none; user-select: none;
      -webkit-user-select: none; -webkit-touch-callout: none; -webkit-user-drag: none;
    }
    #leftStick, #rightStick {
      position: fixed; bottom: 20px; width: 150px; height: 150px; z-index: 10;
      touch-action: none; user-select: none;
      -webkit-user-select: none; -webkit-touch-callout: none; -webkit-user-drag: none;
    }
    #leftStick { left: 20px; }
    #rightStick { right: 20px; }
    #hint {
      position: fixed; left: 8px; right: 8px; top: 8px; z-index: 9;
      background: rgba(0,0,0,.55); color:#fff; padding:8px 10px; border-radius:10px;
      font: 13px/1.4 -apple-system, "Segoe UI", Roboto, Helvetica, Arial;
      user-select: none; -webkit-user-select: none; -webkit-touch-callout: none;
    }
  </style>
</head>

<body>
  <div id="hint">左＝上昇/下降+回転｜右＝前後左右移動｜再検出で1体だけに維持🚁</div>
  <div id="leftStick"></div>
  <div id="rightStick"></div>

  <a-scene embedded arjs="trackingMethod: best; debugUIEnabled: false;">
    <!-- HIROマーカー（idを付ける） -->
    <a-marker preset="hiro" id="marker">
      <!-- ★ ドローン部分はそのまま（変更なし） -->
      <a-entity id="droneModel"
        gltf-model="drone.glb"
        position="0 0.5 -1"
        scale="2.0 2.0 2.0"
        rotation="0 0 0"></a-entity>
    </a-marker>

    <a-entity id="worldRoot"></a-entity>
    <a-entity camera></a-entity>
  </a-scene>

  <script>
    const worldRoot = document.getElementById('worldRoot');
    const marker = document.getElementById('marker');

    let drone = null;          // 生成した機体（常に1体）
    let spawning = false;      // 同時多発生成のガード
    let lastSpawn = 0;         // デバウンス用
    let rotors = [];

    const pos = new THREE.Vector3(0, 0, 0);
    const yawEuler = new THREE.Euler(0, THREE.MathUtils.degToRad(180), 0, 'XYZ');
    let currentTilt = { pitch: 0, roll: 0 };

    const SPEED_FWD = 0.020;
    const SPEED_STRAFE = 0.008;
    const SPEED_Y = 0.015;
    const SPEED_YAW = 1.2;
    const TILT_MAX = 10;
    const TILT_SMOOTH = 0.12;

    let takeoff = { active: false, start: 0, dur: 1200, lift: 0.25, vibAmp: 0.01 };
    let hover = { phase: 0, amp: 0.02, speed: 2.3 };

    const rotorConfig = { rpmIdle: 900, rpmMax: 2200, axis: new THREE.Vector3(0, 1, 0) };
    let currentRPM = 0;
    function rpmToRadPerSec(rpm){ return rpm * Math.PI * 2 / 60; }

    const manualRotorNames = [
      'mavic_air_dronemavic_air_drone_armsmavic_air_drone_arm_front_rgtmavic_air_drone_front_prop_rgt',
      'mavic_air_dronemavic_air_drone_armsmavic_air_drone_arm_front_lftmavic_air_drone_front_prop_lft',
      'mavic_air_dronemavic_air_drone_arm_rear_rgtmavic_air_drone_armsmavic_air_drone_rear_prop_rgt',
      'mavic_air_dronemavic_air_drone_armsmavic_air_drone_arm_rear_lftmavic_air_drone_rear_prop_lft'
    ];
    function collectRotors(root){
      rotors = [];
      manualRotorNames.forEach(name=>{
        const node = root.getObjectByName(name);
        if (node) rotors.push({ obj: node, axis: rotorConfig.axis.clone() });
      });
      rotors = rotors.filter(r => r.obj !== root);
    }

    // 既存ドローンを確実に破棄
    function removeDrone(){
      if (drone && drone.parentNode) {
        drone.parentNode.removeChild(drone);
      }
      drone = null;
      rotors = [];
    }

    // === ドローン生成 ===
    function spawnDrone() {
      if (spawning) return;
      spawning = true;

      // デバウンス（誤連打防止）
      const now = performance.now();
      if (now - lastSpawn < 500) { spawning = false; return; }
      lastSpawn = now;

      // 前の機体を消す → 1体だけ維持
      removeDrone();

      // 新規作成（ドローンの設定はあなたのまま）
      drone = document.createElement('a-entity');
      drone.setAttribute('gltf-model', 'drone.glb'); // ← そのまま
      drone.setAttribute('scale', '2.0 2.0 2.0');     // ← そのまま
      drone.setAttribute('rotation', '0 180 0');

      drone.addEventListener('model-loaded', () => {
        const root = drone.getObject3D('mesh') || drone.object3D;
        if (root) collectRotors(root);
      });
      worldRoot.appendChild(drone);

      // マーカー姿勢から少し上＆少し奥へ（scale 2.0 前提で見やすく）
      const mPos = new THREE.Vector3();
      const mQuat = new THREE.Quaternion();
      const mScale = new THREE.Vector3();
      marker.object3D.matrixWorld.decompose(mPos, mQuat, mScale);

      const offsetLocal = new THREE.Vector3(0, 0.12, -0.60); // 👈 少し遠めに
      offsetLocal.applyQuaternion(mQuat);
      pos.copy(mPos).add(offsetLocal);

      yawEuler.set(0, THREE.MathUtils.degToRad(180), 0);
      currentTilt = { pitch: 0, roll: 0 };

      drone.object3D.position.copy(pos);
      drone.object3D.rotation.set(currentTilt.pitch, yawEuler.y, currentTilt.roll);

      // 離陸
      takeoff.active = true;
      takeoff.start = performance.now();
      currentRPM = rotorConfig.rpmIdle * 0.2;

      // 初回は姿勢安定のため少し遅らせてもOK（必要なら↓を有効化）
      // setTimeout(()=>{ spawning=false; }, 200);
      spawning = false;
    }

    // markerFoundで生成（再検出でも常に1体に保つ）
    marker.addEventListener('markerFound', () => {
      // 初回0.3秒待ってから生成するとチラつき減る
      setTimeout(spawnDrone, 300);
    });

    // === ジョイスティック ===
    const input = { left:{x:0,y:0,active:false}, right:{x:0,y:0,active:false} };
    const stopTouch = e => { e.preventDefault(); e.stopPropagation(); return false; };
    document.addEventListener('touchstart', stopTouch, { passive: false });
    document.addEventListener('touchmove',  stopTouch, { passive: false });

    const left = nipplejs.create({ zone: document.getElementById('leftStick'),  mode:'static', position:{left:'75px',bottom:'75px'}, color:'white' });
    const right= nipplejs.create({ zone: document.getElementById('rightStick'), mode:'static', position:{right:'75px',bottom:'75px'}, color:'white' });
    left.on('move',(_,d)=>{input.left.active=true;input.left.x=d.vector.x;input.left.y=d.vector.y;});
    left.on('end',()=>{input.left.active=false;input.left.x=0;input.left.y=0;});
    right.on('move',(_,d)=>{input.right.active=true;input.right.x=d.vector.x;input.right.y=d.vector.y;});
    right.on('end',()=>{input.right.active=false;input.right.x=0;input.right.y=0;});

    // === ループ ===
    function rpmToDelta(dt){ return rpmToRadPerSec(currentRPM) * dt; }

    function tick() {
      requestAnimationFrame(tick);
      if (!drone) return;

      const now = performance.now();
      const dt = 0.016;

      let takeoffOffset = 0;
      if (takeoff.active) {
        const t = Math.min(1, (now - takeoff.start) / takeoff.dur);
        const e = 1 - Math.pow(1 - t, 3);
        takeoffOffset = e * takeoff.lift + Math.sin(now * 0.06) * 0.01 * (1 - e);
        if (t >= 1) takeoff.active = false;
        const target = rotorConfig.rpmIdle;
        currentRPM += (target - currentRPM) * 0.06;
      } else {
        hover.phase += hover.speed * dt;
        takeoffOffset = Math.sin(hover.phase) * hover.amp;
        const thrust = Math.max(0, input.left.y) + Math.abs(input.right.y) + Math.abs(input.right.x);
        const target = rotorConfig.rpmIdle + (rotorConfig.rpmMax - rotorConfig.rpmIdle) * Math.min(1, thrust * 0.6);
        currentRPM += (target - currentRPM) * 0.08;
      }

      // 移動
      pos.y += input.left.y * SPEED_Y;
      yawEuler.y += THREE.MathUtils.degToRad(-input.left.x * SPEED_YAW);
      pos.z += -input.right.y * SPEED_FWD;
      pos.x +=  input.right.x * SPEED_STRAFE;

      // 見た目チルト
      const targetPitch = THREE.MathUtils.degToRad(TILT_MAX * input.right.y);
      const targetRoll  = THREE.MathUtils.degToRad(-TILT_MAX * input.right.x);
      currentTilt.pitch = THREE.MathUtils.lerp(currentTilt.pitch, targetPitch, TILT_SMOOTH);
      currentTilt.roll  = THREE.MathUtils.lerp(currentTilt.roll,  targetRoll,  TILT_SMOOTH);

      drone.object3D.position.set(pos.x, pos.y + takeoffOffset, pos.z);
      drone.object3D.rotation.set(currentTilt.pitch, yawEuler.y, currentTilt.roll);

      // プロペラ回転
      if (rotors.length > 0 && currentRPM > 1) {
        const dAngle = rpmToDelta(dt);
        for (const r of rotors) r.obj.rotateOnAxis(r.axis, dAngle);
      }
    }
    requestAnimationFrame(tick);
  </script>
</body>
</html>
